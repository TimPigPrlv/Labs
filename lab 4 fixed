using System.Diagnostics;

namespace lab3_2var;

class Program
{
    static void Main(string[] args)
    {
        bool isExiting = false;
        var game = new TetrisGame();
        game.Start();
        while (!isExiting)
        {
            Console.WriteLine("--- –ú–µ–Ω—é –ø—Ä–æ–≥—Ä–∞–º–º—ã ---");
            Console.WriteLine("1. –£–≥–∞–¥–∞–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç");
            Console.WriteLine("2. –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ–± –∞–≤—Ç–æ—Ä–µ");
            Console.WriteLine("3. –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –º–∞—Å—Å–∏–≤–∞");
            Console.WriteLine("4. –í—ã—Ö–æ–¥");
            Console.WriteLine("5.–ò–≥—Ä–∞ –¢–µ—Ç—Ä–∏—Å");
            Console.Write("–í—ã–±–µ—Ä–∏—Ç–µ –ø—É–Ω–∫—Ç –º–µ–Ω—é: ");

            string menuChoice = Console.ReadLine()?.Trim() ?? "";

            switch (menuChoice)
            {
                case "1":
                    PlayGuessingGame();
                    break;
                case "2":
                    ShowAuthorInfo();
                    break;
                case "3":
                    PerformArraySorting();
                    break;
                case "4":
                    isExiting = ConfirmExit();
                    break;
                case "5":
                    game.Start();
                    break;

                default:
                    Console.WriteLine("–û—à–∏–±–∫–∞! –í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ –æ—Ç 1 –¥–æ 4.");
                    break;
            }
        }
    }
    static void PlayGuessingGame()
    {
        Console.WriteLine("--- –£–≥–∞–¥–∞–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç ---");
        double numberA = ReadDoubleInput("–í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ A:");
        double numberB = ReadDoubleInput("–í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ B:");
        double correctAnswer = ComputeAnswer(numberA, numberB);

        TestUserGuess(correctAnswer);
    }

    static double ReadDoubleInput(string prompt = "–í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ (—Å –ø–ª–∞–≤–∞—é—â–µ–π —Ç–æ—á–∫–æ–π):")
    {
        Console.WriteLine(prompt);
        double result = 0.0;
        bool valid = false;

        while (!valid)
        {
            string input = Console.ReadLine()?.Trim() ?? "";

            try
            {
                result = double.Parse(input);
                valid = true;
            }
            catch
            {
                Console.WriteLine("–í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ:");
            }
        }

        return result;
    }

    static double ComputeAnswer(double a, double b)
    {
        return Math.PI * 5 * Math.Log(b) / (Math.Sin(a) + 1);
    }

    static void ShowAuthorInfo()
    {
        Console.WriteLine("--- –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ–± –∞–≤—Ç–æ—Ä–µ ---");
        Console.WriteLine("–ê–≤—Ç–æ—Ä: –¢–∏–º–æ—Ñ–µ–π –°–µ—Ä–≥–µ–µ–≤–∏—á –ü—Ä–∏–≤–∞–ª–æ–≤");
        Console.WriteLine("–°—Ç—É–¥–µ–Ω—Ç –≥—Ä—É–ø–ø—ã 6101-090301D");
    }

    static void TestUserGuess(double correctAnswer)
    {
        const int maxAttempts = 3;
        Console.WriteLine($"–£–≥–∞–¥–∞–π—Ç–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤—ã—á–∏—Å–ª–µ–Ω–∏—è. –£ –≤–∞—Å –µ—Å—Ç—å {maxAttempts} –ø–æ–ø—ã—Ç–∫–∏.");

        for (int attempt = 1; attempt <= maxAttempts; attempt++)
        {
            bool c  = true;
            while (c==true)
            { 
            double userGuess = ReadDoubleInput("–í–≤–µ–¥–∏—Ç–µ –≤–∞—à –æ—Ç–≤–µ—Ç:");
            
            
            
                if (Math.Abs(userGuess - correctAnswer) < 0.0001)
                {
                    Console.WriteLine($"–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –í—ã —É–≥–∞–¥–∞–ª–∏ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç: {correctAnswer}");
                    c = false;
                }
                Console.WriteLine($"–ù–µ–≤–µ—Ä–Ω–æ. –û—Å—Ç–∞–ª–æ—Å—å –ø–æ–ø—ã—Ç–æ–∫: {maxAttempts - attempt}");


                Console.WriteLine($"–í—ã –ø—Ä–æ–∏–≥—Ä–∞–ª–∏! –ü—Ä–∞–≤–∏–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç: {correctAnswer}");
            }
        }
    }

    static void PerformArraySorting()
    {
        Console.WriteLine("--- –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –º–∞—Å—Å–∏–≤–∞ ---");

        int arrayLength = ReadInt();
        int[] randomArray = GenerateRandomArray(arrayLength);

        Console.WriteLine("–ò—Å—Ö–æ–¥–Ω—ã–π –º–∞—Å—Å–∏–≤:");
        PrintArray(randomArray);

        Console.WriteLine("–°—Ä–∞–≤–Ω–∏–≤–∞–µ–º –ø—É–∑—ã—Ä—å–∫–æ–≤—É—é —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫—É –∏ —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫—É –≤—Å—Ç–∞–≤–∫–∞–º–∏...");
        CompareSortingAlgorithms(randomArray);
    }

    static int ReadInt()
    {
        int x;
        string y = Console.ReadLine();
        while (!(int.TryParse(y, out x)) || x <= 0)
        {
            Console.WriteLine("–û—à–∏–±–∫–∞! –í–≤–µ–¥–∏—Ç–µ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ");
            y = Console.ReadLine();

        }
        return x;
        
    }


    static int[] GenerateRandomArray(int length)
    {
        int[] array = new int[length];
        Random random = new();

        for (int i = 0; i < length; i++)
        {
            array[i] = random.Next(-100, 100);
        }

        return array;
    }
    static int[] CopyArray(int[]a)
    {
        int[] b = new int[a.Length];
        for (int i=0; i < a.Length; i++)
        {
            b[i] = a[i];
        }
        return b;
    }

    static void PrintArray(int[] array)
    {
        if (array.Length <= 10)
        {
            Console.WriteLine(string.Join(", ", array));
        }
        else
        {
            Console.WriteLine("–ú–∞—Å—Å–∏–≤ —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è. (–Ω–µ —à–º–æ–≥–ª–∞ :( )");
        }
    }

    static void CompareSortingAlgorithms(int[] array)
    {
        int[] bubbleSortArray = array;
        int[] insertionSortArray = array;

        Console.WriteLine("–ü—É–∑—ã—Ä—å–∫–æ–≤–∞—è —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞:");
        double bubbleSortTime = MeasureExecutionTime(() => BubbleSort(bubbleSortArray));
        PrintArray(bubbleSortArray);

        Console.WriteLine("–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –≤—Å—Ç–∞–≤–∫–∞–º–∏:");
        double insertionSortTime = MeasureExecutionTime(() => InsertionSort(insertionSortArray));
        PrintArray(insertionSortArray);

        Console.WriteLine($"–í—Ä–µ–º—è –ø—É–∑—ã—Ä—å–∫–æ–≤–æ–π —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏: {bubbleSortTime} –º—Å");
        Console.WriteLine($"–í—Ä–µ–º—è —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏ –≤—Å—Ç–∞–≤–∫–∞–º–∏: {insertionSortTime} –º—Å");

        if (bubbleSortTime < insertionSortTime)
        {
            Console.WriteLine("–ü—É–∑—ã—Ä—å–∫–æ–≤–∞—è —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –±—ã—Å—Ç—Ä–µ–µ.");
        }
        else
        {
            Console.WriteLine("–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –≤—Å—Ç–∞–≤–∫–∞–º–∏ –±—ã—Å—Ç—Ä–µ–µ.");
        }
    }

    static double MeasureExecutionTime(Action sortingFunction)
    {
        Stopwatch stopwatch = Stopwatch.StartNew();
        sortingFunction();
        stopwatch.Stop();
        return stopwatch.Elapsed.TotalMilliseconds;
    }

    static void BubbleSort(int[] array)
    {
        for (int i = 0; i < array.Length - 1; i++)
        {
            for (int j = 0; j < array.Length - i - 1; j++)
            {
                if (array[j] > array[j + 1])
                {
                    int temp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = temp;
                }
            }
        }
    }

    static void InsertionSort(int[] array)
    {
        for (int i = 1; i < array.Length; i++)
        {
            int key = array[i];
            int j = i - 1;

            while (j >= 0 && array[j] > key)
            {
                array[j + 1] = array[j];
                j--;
            }
            array[j + 1] = key;
        }
    }

    static bool ConfirmExit()
    {
        Console.WriteLine("–í—ã —Ç–æ—á–Ω–æ —Ö–æ—Ç–∏—Ç–µ –≤—ã–π—Ç–∏? [–¥/–Ω]");
        string input;
        bool a = true;
        bool b = true;
        do
        {
            input = Console.ReadLine()?.Trim().ToLower() ?? "";
            if (input == "–¥")
            {
                Console.WriteLine("–ü—Ä–æ–≥—Ä–∞–º–º–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞. –î–æ —Å–≤–∏–¥–∞–Ω–∏—è!");
                a = false;
            }
            else if (input == "–Ω")
            {
                Console.WriteLine("–í–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –≤ –º–µ–Ω—é...");
                a = false;
                b = true;
            }
            else
            {
                Console.WriteLine("–û—à–∏–±–∫–∞ –≤–≤–æ–¥–∞. –í–≤–µ–¥–∏—Ç–µ '–¥' –¥–ª—è –≤—ã—Ö–æ–¥–∞ –∏–ª–∏ '–Ω' –¥–ª—è –≤–æ–∑–≤—Ä–∞—Ç–∞.");
                a = true;
            }
        } while (a);
        return b;
    }
}
    

    public class TetrisGame
{ 
    private readonly GameField _gameField;
    private readonly Random _random;

    public TetrisGame()
    {
        _gameField = new GameField(10, 10);
        _random = new Random();
    }

    public void Start()
    {
        Console.WriteLine("Welcome to Tetris!");
        Console.WriteLine("Controls: A - Move Left, D - Move Right, S - Move Down, W - Rotate");

        try
        {
            while (_gameField.HasSpaceForNewFigure())
            {
                var figure = TetrisFigureFactory.CreateRandomFigure(_random);
                _gameField.SpawnFigure(figure);
                _gameField.Render();

                while (_gameField.CanMoveCurrentFigure)
                {
                    string input = GetUserInput();
                    Movement? direction = GetMovement(input);

                    if (direction.HasValue)
                    {
                        _gameField.HandleMove(direction.Value);
                        _gameField.Render();
                    }
                    else
                    {
                        Console.WriteLine("Invalid input!");
                    }
                }
            }
            Console.WriteLine("Game Over");
            Console.WriteLine($"Final Score: {_gameField.Score}");
        }
        catch (Exception ex)
        {
            Console.WriteLine("Game Over");
            Console.WriteLine($"Final Score: {_gameField.Score}");
        }
    }

    private static string GetUserInput()
    {
        Console.Write("Enter your move: ");
        var key = Console.ReadKey(intercept: true);
        Console.WriteLine();
        return key.KeyChar.ToString().ToUpper();
    }

    private static Movement? GetMovement(string input)
    {
        return input.ToUpper() switch
        {
            "A" => Movement.Left,
            "D" => Movement.Right,
            "S" => Movement.Down,
            " " => Movement.Down,
            "W" => Movement.Rotate,
            _ => null
        };
    }
}

public class GameField
{
    private readonly int[,] _matrix;
    private readonly int _rows;
    private readonly int _columns;
    private TetrisFigure? _activeFigure;
    private Position? _activePosition;
    public int Score { get; private set; }

    public GameField(int rows, int columns)
    {
        _rows = rows;
        _columns = columns;
        _matrix = new int[rows, columns];
    }

    public bool HasSpaceForNewFigure()
    {
        for (int col = 0; col < _columns; col++)
        {
            if (_matrix[0, col] != 0)
            {
                return false;
            }
        }
        return true;
    }

    public void SpawnFigure(TetrisFigure figure)
    {
        Console.WriteLine("Spawning new figure");
        _activeFigure = figure;
        _activePosition = new Position(0, (_columns - figure.Width) / 2);

        if (CalculateCollision(_activePosition, figure) != CollistionType.None)
        {
            throw new InvalidOperationException("Game Over");
        }
    }

    public bool CanMoveCurrentFigure => _activeFigure != null && _activePosition != null;

    public void HandleMove(Movement direction)
    {
        if (_activeFigure == null || _activePosition == null)
        {
            return;
        }

        Console.WriteLine($"Current Position: {_activePosition.Row}, {_activePosition.Column}");

        Position newPosition = direction switch
        {
            Movement.Left => _activePosition with { Column = _activePosition.Column - 1 },
            Movement.Right => _activePosition with { Column = _activePosition.Column + 1 },
            Movement.Down => _activePosition with { Row = _activePosition.Row + 1 },
            _ => _activePosition
        };

        Console.WriteLine($"New Position: {newPosition.Row}, {newPosition.Column}");

        if (direction == Movement.Rotate)
        {
            var rotatedFigure = _activeFigure.Rotate();
            if (CalculateCollision(_activePosition, rotatedFigure) == CollistionType.None)
            {
                _activeFigure = rotatedFigure;
            }
            else
            {
                Console.WriteLine("Cannot rotate the figure, it will overlap with existing blocks.");
            }
        }
        else
        {
            if (CalculateCollision(newPosition, _activeFigure) == CollistionType.None)
            {
                _activePosition = newPosition;
            }
            else
            {
                var collision = CalculateCollision(newPosition, _activeFigure);
                if (collision == CollistionType.Left || collision == CollistionType.Right)
                {
                    Console.WriteLine($"Cannot move {direction}, moving it down instead.");
                    HandleMove(Movement.Down);
                }
                else
                {
                    if (direction == Movement.Down)
                    {
                        Console.WriteLine("Cannot move down, placing the figure on the field.");
                        PlaceFigure(_activePosition, _activeFigure);
                        FixCurrentFigure();
                    }
                }
            }
        }
    }
    private void FixCurrentFigure()
    {
        _activeFigure = null;
        _activePosition = null;
        ClearFullRows();
    }

    private void ClearFullRows()
    {
        for (int row = 0; row < _rows; row++)
        {
            if (IsRowFull(row))
            {
                ClearRow(row);
                DropRowsAbove(row);
                Score += 10;
            }
        }
    }

    private bool IsRowFull(int row)
    {
        for (int col = 0; col < _columns; col++)
        {
            if (_matrix[row, col] == 0)
                return false;
        }
        return true;
    }

    private void ClearRow(int row)
    {
        for (int col = 0; col < _columns; col++)
            _matrix[row, col] = 0;
    }

    private void DropRowsAbove(int row)
    {
        for (int i = row; i > 0; i--)
        {
            for (int col = 0; col < _columns; col++)
            {
                _matrix[i, col] = _matrix[i - 1, col];
            }
        }
        for (int col = 0; col < _columns; col++)
        {
            _matrix[0, col] = 0;
        }
    }

    private CollistionType CalculateCollision(Position position, TetrisFigure figure)
    {
        for (int i = 0; i < figure.Height; i++)
        {
            for (int j = 0; j < figure.Width; j++)
            {
                if (figure.Shape[i, j] == 1)
                {
                    int row = position.Row + i;
                    int col = position.Column + j;
                    if (row < 0)
                    {
                        return CollistionType.Bottom;
                    }
                    if (row >= _rows)
                    {
                        return CollistionType.Block;
                    }
                    if (col < 0)
                    {
                        return CollistionType.Left;
                    }
                    if (col >= _columns)
                    {
                        return CollistionType.Right;
                    }
                    if (_matrix[row, col] == 1)
                    {
                        return CollistionType.Block;
                    }

                    
                }
            }
        }
        return CollistionType.None;
    }

    public enum CollistionType
    {
        None,
        Left,
        Right,
        Bottom,
        Block
    }

    private void PlaceFigure(Position position, TetrisFigure figure)
    {
        for (int i = 0; i < figure.Height; i++)
        {
            for (int j = 0; j < figure.Width; j++)
            {
                if (figure.Shape[i, j] == 1)
                {
                    _matrix[position.Row + i, position.Column + j] = 1;
                }
            }
        }
    }

    private void ClearActiveFigure()
    {
        if (_activeFigure == null || _activePosition == null)
            return;

        for (int i = 0; i < _activeFigure.Height; i++)
        {
            for (int j = 0; j < _activeFigure.Width; j++)
            {
                if (_activeFigure.Shape[i, j] == 1)
                {
                    _matrix[_activePosition.Row + i, _activePosition.Column + j] = 0;
                }
            }
        }
    }

    public void Render()
    {
        Console.WriteLine("‚ïî" + new string('‚ïê', _columns * 3) + "‚ïó");

        for (int i = 0; i < _rows; i++)
        {
            Console.Write("‚ïë");
            for (int j = 0; j < _columns; j++)
            {
                if (_matrix[i, j] == 1)
                {
                    Console.Write("üü¶ ");
                }
                else
                {
                    if (_activeFigure != null && _activePosition != null &&
                         IsPartOfActiveFigure(i, j, _activePosition, _activeFigure))
                    {
                        Console.Write("üü¶ ");
                    }
                    else
                    {
                        Console.Write("‚¨ú ");
                    }
                }
            }
            Console.WriteLine("‚ïë");
        }

        Console.WriteLine("‚ïö" + new string('‚ïê', _columns * 3) + "‚ïù");

        if (_activeFigure != null && _activePosition != null)
        {
            Console.WriteLine($"Current Figure: \n{_activeFigure}");
        }
    }
    private bool IsPartOfActiveFigure(int row, int col, Position position, TetrisFigure figure)
    {
        for (int i = 0; i < figure.Height; i++)
        {
            for (int j = 0; j < figure.Width; j++)
            {
                if (figure.Shape[i, j] == 1 &&
                    position.Row + i == row &&
                    position.Column + j == col)
                {
                    return true;
                }
            }
        }
        return false;
    }
}

public record TetrisFigure(int[,] Shape, ShapeType Type)
{
    public int Width => Shape.GetLength(1);
    public int Height => Shape.GetLength(0);

    public TetrisFigure Rotate()
    {
        int newHeight = Width;
        int newWidth = Height;
        var rotatedShape = new int[newHeight, newWidth];

        for (int i = 0; i < Height; i++)
        {
            for (int j = 0; j < Width; j++)
            {
                rotatedShape[j, newWidth - i - 1] = Shape[i, j];
            }
        }

        return new TetrisFigure(rotatedShape, Type);
    }

    public override string ToString()
    {
        var sb = new System.Text.StringBuilder();
        for (int i = 0; i < Height; i++)
        {
            for (int j = 0; j < Width; j++)
            {
                sb.Append(Shape[i, j] == 1 ? "üü¶" : "‚¨ú");
            }
            sb.AppendLine();
        }
        return sb.ToString();
    }
}

public record Position(int Row, int Column);

public static class TetrisFigureFactory
{
    private static readonly Dictionary<ShapeType, int[,]> CanonicalFigures = new()
        {
            { ShapeType.Square, new[,] { { 1, 1 }, { 1, 1 } } },
            { ShapeType.Line, new[,] { { 1, 1, 1, 1 } } },
            { ShapeType.L, new[,] { { 1, 1 }, { 1, 0 }, { 1, 0 } } },
            { ShapeType.J, new[,] { { 1, 1 }, { 0, 1 }, { 0, 1 } } },
            { ShapeType.Z, new[,] { { 0, 1, 1 }, { 1, 1, 0 } } },
            { ShapeType.S, new[,] { { 1, 1, 0 }, { 0, 1, 1 } } },
            { ShapeType.T, new[,] { { 1, 1, 1 }, { 0, 1, 0 } } }
        };
    public static TetrisFigure CreateFigure(ShapeType type)
    {
        Console.WriteLine($"Creating figure '{type}'");
        if (CanonicalFigures.TryGetValue(type, out var shape))
        {
            return new TetrisFigure(shape, type);
        }

        throw new ArgumentException($"Figure '{type}' is not recognized.", nameof(type));
    }

    public static TetrisFigure CreateRandomFigure(Random random)
    {
        var figureTypes = Enum.GetValues<ShapeType>();
        ShapeType randomType = figureTypes[random.Next(figureTypes.Length)];
        return CreateFigure(randomType);
    }
}

public enum ShapeType
{
    Square,
    Line,
    L,
    J,
    Z,
    S,
    T
}

public enum Movement
{
    Left,
    Right,
    Down,
    Rotate
}






    

